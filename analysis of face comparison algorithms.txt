(http://algotravelling.com/ru/%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%8D%D1%82%D0%BE-%D0%B2%D0%B5%D1%81%D0%B5%D0%BB%D0%BE-4/)
Шаг 1. Поиск всех лиц
На первом этапе нашего конвейера нужно обнаружить лица. Ясное дело, нам нужно найти лица на фотографии, прежде чем делать что-то еще.
Обнаружение лиц стало мейнстримом в начале 2000-х годов, когда Пол Виола (Paul Viola) и Майкл Джонс (Michael Jones) изобрели способ обнаружения лиц, который был достаточно быстрым, чтобы работать на дешевых камерах. Однако сегодня существуют более надежные решения. Мы собираемся использовать метод, изобретенный в 2005 году – гистограмма направленных градиентов (Histogram of Oriented Gradients) – или просто HOG, для краткости.

1) Чтобы найти лица на изображении, сперва сделаем наше изображение черно-белым, потому что для поиска лиц цветовые данные не нужны.
2) Затем мы рассмотрим каждый пиксель на нашем изображении, один за другим. Но интересует нас не столько сам пиксель, сколько пиксели, окружающие его: 
Наша цель – выяснить, насколько темным является текущий пиксель по сравнению с соседними. Затем мы рисуем стрелку, показывающую, в каком направлении изображение становится темнее. Выполнив эту процедуру для каждого отдельного пикселя изображения, вы замените каждый пиксель стрелкой. Эти стрелки называются градиентами, и они показывают направление от светлых пикселей к темным по всему изображению.
3) Может показаться, что этот метод выбран случайно, но на самом деле есть резонная причина заменять пиксели градиентами. Если мы проанализируем пиксели напрямую, то увидим, что темные изображения и светлые изображения одного и того же человека будут иметь совершенно разные значения яркости пикселей. Но, рассматривая только направление изменения яркости, мы получим одинаковую картину независимо от яркости исходного изображения. Это значительно упрощает задачу!

Однако, сохранение градиента для каждого пикселя – это слишком много информации, и мы можем не увидеть леса за деревьями. Было бы лучше, если бы мы могли увидеть основное направление изменения света на более высоком уровне, получая таким образом общую канву изображения.

Для этого мы разделим изображение на маленькие квадраты размером 16x16 пикселей каждый. В каждом квадрате мы подсчитаем, сколько точек градиента повернуто в каждом из основных направлений (вверх, вверх, вправо, вправо и т. д.). Затем мы заменим этот квадрат на изображении стрелочками, направленными туда же, куда и большинство.

В конечном итоге мы преобразуем исходное изображение так, что ясно проглядывается базовая структура лица:

Чтобы найти лицо на HOG-изображении, все, что нам нужно сделать, – это найти часть нашего изображения, которая наиболее похожа на известный рисунок HOG, полученный из множества других лиц в ходе обучения:

Используя этот метод, мы легко можем найти лица на любом изображении:

Если вы хотите попробовать сделать это самостоятельно, используя Python и dlib, то код, показывающий, как создавать и просматривать представления HOG-изображений, можно найти здесь.
Шаг 2. Расположение лиц

Так, лица найти удалось. Но теперь мы должны разобраться с проблемой, когда лица, повернутые в разные стороны, кажутся компьютеру разными лицами:

Для решения проблемы мы попытаемся преобразовать каждое изображение так, чтобы глаза и губы всегда находились в каком-то конкретном месте. Это упростит задачу сравнения лиц на следующих этапах.

Для этого мы будем использовать алгоритм под названием оценка ориентиров лица (face landmark estimation). Есть много способов сделать это, но мы будем использовать метод, изобретенный в 2014 году Вахидом Каземи (Vahid Kazemi) и Жозефиной Салливан (Josephine Sullivan).

Основная идея состоит в том, что мы отметим 68 особых точек (называемых ориентирами), которые существуют на каждом лице – верхняя часть подбородка, внешняя точка каждого глаза, внутренняя точка каждой брови и т. д. Затем мы обучим алгоритм машинного обучения находить эти 68 особых точек на любом лице:

Вот результат размещения 68 ориентиров на нашем тестовом изображении:

Теперь, когда мы знаем, где глаза и где рот, мы можем вращать, масштабировать и сдвигать изображение так, чтобы глаза и рот были как можно лучше центрированы. При этом мы не будем делать никаких фантастических трехмерных искажений, так как это портит изображение. Мы будем использовать только базовые преобразования изображений, такие как поворот и масштабирование, которые сохраняют параллельные линии (аффинные преобразования):

Теперь, независимо от того, как повернуто лицо, мы можем центрировать глаза и рот примерно в одно и то же положение на изображении. Это позволит сделать следующий этап более точным.

Если вы хотите попробовать сделать это самостоятельно, используя Python и dlib, то по ссылкам вы найдете код для поиска ориентиров на лице и код для преобразования изображения с использованием этих ориентиров.
Шаг 3. Кодирование лица

Теперь мы подходим к сути проблемы – как отличить одно лицо от другого. И здесь все становится действительно интересно!

Самый простой подход к распознаванию лица заключается в непосредственном сравнении неизвестного лица, которое мы обнаружили на шаге 2, со всеми изображениями людей, которые уже были отмечены ранее. Если мы находим ранее отмеченное лицо, которое очень похоже на распознаваемое лицо, то это наверняка один и тот же человек – разве не гениальная идея?

Оказывается, что измерения, которые кажутся людям очевидными (например, цвет глаз), на самом деле не имеют смысла для компьютера, рассматривающего отдельные пиксели изображения. Исследователи показали, что самый точный подход – это позволить компьютеру самому измерить то, что ему нужно. Глубокое обучение, определяет, какие части лица нужно измерять, лучше, чем люди.

Решение заключается в создании сверточной нейронной сети глубокого обучения (как и в части 3). Но вместо того, чтобы обучать сеть распознавать объекты на изображении, как мы делали в прошлый раз, мы научим ее создавать 128 измерений для каждого лица.

Во время обучения сети анализируется одновременно три лица:

    Обучающее изображение лица известного человека
    Другая фотография того же известного человека
    Изображение совершенно другого человека

Затем алгоритм просматривает измерения, которые он делает для каждого из этих трех изображений. Затем он немного настраивает нейронную сеть, чтобы удостовериться, что измерения, созданные для изображений #1 и #2, будут более похожи, а измерения для #2 и #3 – менее похожи:

Повторив этот этап миллионы раз для миллионов изображений тысяч разных людей, нейронная сеть учится надежно создавать 128 измерений для каждого человека. Любые десять разных изображений одного и того же человека должны давать примерно одинаковые измерения.

Полученные 128 измерений каждого лица называют картой. Идея преобразования массива необработанных данных, например, изображения, в список генерируемых компьютером чисел крайне важна для машинного обучения (особенно для автоматизированного перевода). Тот подход к лицам, который мы используем, был изобретен в 2015 году исследователями Google, но существует также много аналогичных подходов.

Кодирование изображения лица

Этот процесс обучения сверточной нейронной сети для получения карты лиц требует большого количества данных и мощного компьютера. Даже при использовании дорогой видеокарты NVidia Telsa требуется 24 часа непрерывного обучения, чтобы получить хорошую точность.

Но как только сеть будет обучена, она сможет генерировать измерения для любого лица, даже такого, которое видит впервые! Поэтому это нужно сделать всего один раз. К счастью для нас, ребята из OpenFace уже сделали это и опубликовали несколько обученных сетей, которые мы можем использовать. Спасибо, Брэндону Амосу (Brandon Amos) и его команде!

Таким образом, нам остается только пропустить изображения лиц через готовую обученную сеть, чтобы получить 128 измерений для каждого лица. Ниже приведены результаты измерений для нашего тестового изображения:

А каким частям лица соответствуют эти 128 чисел? А мы и понятия не имеем. Но для нас это не имеет большого значения. Нас интересует только то, что сеть генерирует почти одинаковые числа по двум изображениям одного и того же человека.